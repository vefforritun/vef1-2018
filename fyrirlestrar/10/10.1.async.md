---
title: Fyrirlestur 10.1 – Ósamstillt forritun
---

# Fyrirlestur 10.1 – Ósamstillt forritun

## Vefforritun 1 — TÖL107G

### Ólafur Sverrir Kjartansson, [osk@hi.is](mailto:osk@hi.is)

---

## Ósamstillt forritun (async programming)

* Þegar forritin okkar fara að nýta hluti sem eru ekki í minni þurfum við að beita öðrum aðferðum í forritun
* Það er _hratt_ að sækja hluti í minni, _hægara_ að sækja á disk og (oftast) enn _hægara_ að sækja yfir net
* Bíðum ekki eftir því að beiðni klárist, nýtum _ósamstillta forritun_ (asynchronous/async programming)

***

## Samstillt forritun

* Forrit sem þið hafið séð hingað til eru samstillt—þau keyra eina línu í einu, eitt fall í einu—eru línuleg
* Hægt að nota _þræði_, JavaScript hefur **ekki** stuðning við þá
* Notum async forritun með _event loop_ á einum þræði
* Höldum CPU ekki uppteknum á meðan beðið

***

![Dæmi um mismunandi forritun](img/control-io.svg "Mynd frá https://eloquentjavascript.net/11_async.html")

***

## Callbacks

* Ein leið til að vinna með async kóða
* Köllum í fall sem tekur langan tíma með _callback_ argument
* Fallið kallar í _callback_ fall með niðurstöðu þegar búið
* Ef við köllum í annað fall sem tekur langan tíma úr _callback_ þurfum við annað callback o.s.fr. o.s.fr.

***

## setTimeout og setInterval

* Leiðir í JavaScript til að búa til föll sem keyra í framtíðinni
* `setTimeout(callback, delay)` kallar í `callback` fallið eftir `delay` millisekúndur
* `setInterval(callback, interval)` kallar í `callback` á `interval` millisekúndu fresti

***

* Bæði `setTimeout` og `setInterval` skila tölu sem er auðkenni teljara sem var búinn til
* Getum slökkt á teljar með `clearTimeout` eða `clearInterval` sem tekur auðkenni sem argument

***

```javascript
// snoozea í 5s, síðan 3s og að lokum 1s
setTimeout(() => {
  alert('Vakna!');
  setTimeout(() => {
    alert('Vakna núna!');
    setTimeout(() => {
      alert('VAKNA!!');
    }, 1000);
  }, 3000);
}, 5000);
```

***

```javascript
function snooze(s, msg, cb) {
  setTimeout(() => {
    alert(msg);
    if (cb) {
      cb();
    }
  }, 1000*s)
}

snooze(5, 'Vakna', () => {
  snooze(3, 'Vakna núna!', () => {
    snooze(1, 'VAKNA!!');
  });
});
```

***

[`setTimeout` og `setInterval` dæmi](daemi/async/timers.js)

[snooze dæmi](daemi/async/snooze.js)

***

## Promises

* Hjúpun fyrir gildi sem mun verða til í framtíðinni
* Gerir asynchronous forritun auðveldari
* Flóknara hugtak en callbacks

***

* Þegar við skilgreinum Promise köllum við í:
  - `resolve` með gildi þegar við höfum lokið aðgerð
  - `reject` með villu þegar eitthvað fer úrskeiðis

***

* Þegar við vinnum með promise skilgreinum við
  - `then` callback til að vinna með gildið, fær gildi sem argument
  - `catch` callback til að vinna með villu, fær villu sem argument
* `then` og `catch` eru föll á Promise
* Getum sent promise gildi á milli!

***

```javascript
let fifteen = Promise.resolve(15);
fifteen
  .then(v => console.log(`Got ${v}`));
// → Got 15
```

***

## Villur

* Villumeðhöndlun með callbacks verður hratt mjög ólæsilegt og flókið
* Eitt argument fyrir hvað gerist ef við fáum gildi, annað fyrir villu
* Mjög mikið inndreginn kóði, _callback hell_

***

* `catch` eftir `then` í Promise sér um villur í öllum kóða sem á undan kemur
* Þurfum ekki að hafa villumeðhöndlun innan kóða sem sér um að bregðast við gildi

***

```javascript
function futureMessage (msg) {
  return new Promise((resolve, reject) => {
    if (msg === 'foo') reject('No foo!');

    setTimeout(() =>
      resolve(`${msg} from future!`), 2000);
  });
}

futureMessage('Hi!')
  .then(msg => { console.log(msg); });
// "Hi! from future!" eftir 2 sek
```

***

```javascript
futureMessage('foo')
 .then(msg => { console.log(msg); })
 .catch(e => { console.log(e); });
// "No foo!" strax
```

***

```javascript
const p = futureMessage('hmm');
function foo(p) {
  console.log(p);

  p.then(msg => { console.log(msg); });

  return 'Handling promise...';
}
foo(p);
// Promise { ... }
// "Handling promise..."
// "hmm from the future!" eftir 2 sek
```

***

## Stöður á promise

Promise getur verið í einni af þrem stöðum:

* `pending`, verið að bíða eftir gildi
* `fulfilled`, búið að uppfylla loforð með gildi
* `rejected`, búið að hafna loforði með villu

***

```javascript
function snooze(s, msg) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(msg)
    }, s * 1000);
  });
}

snooze(5, 'Vakna')
  .then((msg) => alert(msg))
  .then(() => snooze(3, 'Vakna núna!'))
  .then((msg) => alert(msg))
  .then(() => snooze(1, 'VAKNA!!!'))
  .then((msg) => alert(msg))
```

***

## Promise.all

* `Promise.all` tekur við fylki af Promise og skilar Promise
  - Ef eitthvert rejactarar er Promise rejectað
  - Niðurstaða er fylki með niðurstöðu í réttri röð m.v. uppruna

***

## Promise.race

* `Promise.race` tekur við fylki af Promise og skilar Promise
  - Skilar niðurstöðu úr fyrsta Promise sem lýkur eða rejectar

***

```javascript
const snoozefest = Promise.all([
    snooze(5, 'Vakna'),
    snooze(3, 'Vakna núna!'),
    snooze(1, 'VAKNA!!!'),
  ])
  .then(result => console.log(result));

console.log(snoozefest);
// Promise {<pending>}
// 5s seinna..
// ["Vakna", "Vakna núna!", "VAKNA!!!"]
```

***

```javascript
Promise.race([
  snooze(5, 'Vakna'),
  snooze(3, 'Vakna núna!'),
  snooze(1, 'VAKNA!!!'),
])
.then(result => console.log(result));

// 1s seinna..
// "VAKNA!!!"
```

***

## async og await

* Önnur leið til að vinna með async kóða
* Leyfir okkur að _bíða_ eftir async aðgerð í línulegu flæði
* Merkjum föll sem þarf að bíða eftir með `async`
* Merkjum að við ætlum að bíða með `await`
* Grípum villur með `try catch`

***

```javascript
// snooze fall eins og áður
async function snoozer() {
  alert(await snooze(5, 'Vakna'));
  alert(await snooze(3, 'Vakna núna'));
  alert(await snooze(1, 'VAKNA!!!'));
}

snoozer();
```

***

```javascript
// futureMessage eins og áður
async function future() {
  try {
    const res = await futureMessage('foo');
    console.log(res);
  } catch (e) {
    console.log(e);
  }
}

future();
```

***

* Getum ekki notað `await` í global scope—verður að vera innan `async` falls
* `async` fallið skilar Promise!
  - `async await` er _syntactic sugar_ fyrir Promise
  - Ættum að hafa `catch` á það fall til að vera örugg um að missa ekki af villum

***

## async forritun

* Async forritun er erfið til að byrja með
* Lærum ekki á einum degi eða einni viku en margt af því sem við gerum á vefnum **er** async
* Sjáum dæmi í atburðum og _ajax_ beiðnum
* Förum enn dýpra í vefforritun 2
